#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import sqlite3
from contextlib import closing
from datetime import datetime, timezone


def open_db(path: str) -> sqlite3.Connection:
    conn = sqlite3.connect(path)
    conn.execute("PRAGMA foreign_keys=ON")
    conn.execute("PRAGMA busy_timeout=5000")
    return conn


def iter_target_notes(conn: sqlite3.Connection, note_id: int | None, only_missing: bool):
    if note_id is not None:
        rows = conn.execute("SELECT id FROM note WHERE id=?", (note_id,)).fetchall()
        for (nid,) in rows:
            yield nid
        return
    if only_missing:
        q = "SELECT id FROM note WHERE raw_text IS NULL OR TRIM(raw_text) = '' ORDER BY id"
    else:
        q = "SELECT id FROM note ORDER BY id"
    for (nid,) in conn.execute(q):
        yield nid


def build_note_text(conn: sqlite3.Connection, note_id: int) -> str:
    parts = []
    rows = conn.execute(
        "SELECT page_order, text FROM transcribed_page WHERE note_id=? ORDER BY page_order ASC, id ASC",
        (note_id,),
    ).fetchall()
    for (order, text) in rows:
        text = text or ""
        parts.append(text.rstrip())
    return "\n\n".join([p for p in parts if p]) + ("\n" if parts else "")


def build_metadata(conn: sqlite3.Connection, note_id: int, raw_text: str) -> str:
    page_count = conn.execute(
        "SELECT COUNT(*) FROM transcribed_page WHERE note_id=?",
        (note_id,),
    ).fetchone()[0]
    file_count = conn.execute(
        "SELECT COUNT(*) FROM note_file WHERE note_id=?",
        (note_id,),
    ).fetchone()[0]
    # Basic note info
    note_row = conn.execute(
        "SELECT title, notebook FROM note WHERE id=?",
        (note_id,),
    ).fetchone()
    title = note_row[0] if note_row else None
    notebook = note_row[1] if note_row else None
    # Source mapping
    source_key_row = conn.execute(
        "SELECT source_key FROM note_source WHERE note_id=?",
        (note_id,),
    ).fetchone()
    source_key = source_key_row[0] if source_key_row else None
    # Overall text stats
    chars = len(raw_text)
    lines = raw_text.count("\n") + (1 if raw_text and not raw_text.endswith("\n") else 0)
    words = len([w for w in raw_text.split() if w])
    # Per-page summary
    pages: list[dict] = []
    cur = conn.execute(
        """
        SELECT tp.page_order, tp.id, tp.text, tp.json_path, tp.file_id, tp.page_date,
               f.path, f.original_filename, f.ocr_text_path, f.ocr_json_path, f.sha256
        FROM transcribed_page tp
        LEFT JOIN file f ON tp.file_id = f.id
        WHERE tp.note_id=?
        ORDER BY tp.page_order ASC, tp.id ASC
        """,
        (note_id,),
    )
    for (page_order, tpid, ptext, json_path, file_id, page_date, fpath, orig_name, ocr_txt_path, ocr_json_path, sha256) in cur.fetchall():
        ptext = ptext or ""
        p_chars = len(ptext)
        p_lines = ptext.count("\n") + (1 if ptext and not ptext.endswith("\n") else 0)
        p_words = len([w for w in ptext.split() if w])
        pages.append(
            {
                "page_order": int(page_order) if page_order is not None else None,
                "transcribed_page_id": int(tpid),
                "file_id": int(file_id) if file_id is not None else None,
                "page_date": page_date,
                "image_path": fpath,
                "original_filename": orig_name,
                "ocr_text_path": ocr_txt_path,
                "ocr_json_path": ocr_json_path or json_path,
                "sha256": sha256,
                "text_stats": {"chars": p_chars, "lines": p_lines, "words": p_words},
            }
        )

    # Note-level date
    nrow = conn.execute("SELECT date_created FROM note WHERE id=?", (note_id,)).fetchone()
    note_date = nrow[0] if nrow else None

    meta = {
        "source_key": source_key,
        "title": title,
        "notebook": notebook,
        "date_created": note_date,
        "page_count": int(page_count),
        "file_count": int(file_count),
        "text_stats": {"chars": chars, "lines": lines, "words": words},
        "pages": pages,
        "assembled_at": datetime.now(timezone.utc).isoformat(),
        "assembled_by": "notesdb-assemble",
    }
    return json.dumps(meta, ensure_ascii=False)


def assemble(conn: sqlite3.Connection, note_id: int | None, only_missing: bool, overwrite: bool) -> tuple[int, int]:
    updated = 0
    skipped = 0
    for nid in iter_target_notes(conn, note_id, only_missing):
        row = conn.execute("SELECT raw_text FROM note WHERE id=?", (nid,)).fetchone()
        current = row[0] if row else None
        if current and not overwrite and only_missing:
            skipped += 1
            continue
        raw = build_note_text(conn, nid)
        meta = build_metadata(conn, nid, raw)
        conn.execute(
            "UPDATE note SET raw_text=?, metadata_json=? WHERE id=?",
            (raw, meta, nid),
        )
        updated += 1
    return updated, skipped


def main() -> int:
    ap = argparse.ArgumentParser(description="Assemble note.raw_text and metadata_json from transcribed pages")
    ap.add_argument("--db", default=os.environ.get("NOTES_DB", "/data/notesdb/notes.db"))
    ap.add_argument("--note-id", type=int)
    ap.add_argument("--only-missing", action="store_true", help="Only fill notes with empty raw_text")
    ap.add_argument("--overwrite", action="store_true", help="Overwrite existing raw_text")
    args = ap.parse_args()

    with closing(open_db(args.db)) as conn:
        with conn:
            updated, skipped = assemble(conn, args.note_id, args.only_missing, args.overwrite)
    print(f"[notesdb-assemble] updated={updated} skipped={skipped}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
