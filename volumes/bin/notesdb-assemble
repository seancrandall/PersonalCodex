#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import os
import sqlite3
from contextlib import closing
from datetime import datetime, timezone


def open_db(path: str) -> sqlite3.Connection:
    conn = sqlite3.connect(path)
    conn.execute("PRAGMA foreign_keys=ON")
    conn.execute("PRAGMA busy_timeout=5000")
    return conn


def _has_table(conn: sqlite3.Connection, name: str) -> bool:
    row = conn.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (name,)).fetchone()
    return bool(row)


def _has_column(conn: sqlite3.Connection, table: str, column: str) -> bool:
    try:
        cols = [r[1] for r in conn.execute(f"PRAGMA table_info({table})").fetchall()]
        return column in cols
    except Exception:
        return False


def iter_target_notes(conn: sqlite3.Connection, note_id: int | None, only_missing: bool):
    if note_id is not None:
        rows = conn.execute("SELECT id FROM note WHERE id=?", (note_id,)).fetchall()
        for (nid,) in rows:
            yield nid
        return
    # Support both legacy (raw_text) and new (content) schemas
    target_col = "raw_text" if _has_column(conn, "note", "raw_text") else ("content" if _has_column(conn, "note", "content") else None)
    if target_col is None:
        return
    if only_missing:
        q = f"SELECT id FROM note WHERE {target_col} IS NULL OR TRIM({target_col}) = '' ORDER BY id"
    else:
        q = "SELECT id FROM note ORDER BY id"
    for (nid,) in conn.execute(q):
        yield nid


def build_note_text(conn: sqlite3.Connection, note_id: int) -> str:
    parts = []
    rows = conn.execute(
        "SELECT page_order, text FROM transcribed_page WHERE note_id=? ORDER BY page_order ASC, id ASC",
        (note_id,),
    ).fetchall()
    for (order, text) in rows:
        text = text or ""
        parts.append(text.rstrip())
    return "\n\n".join([p for p in parts if p]) + ("\n" if parts else "")


def build_metadata(conn: sqlite3.Connection, note_id: int, raw_text: str) -> str:
    page_count = conn.execute(
        "SELECT COUNT(*) FROM transcribed_page WHERE note_id=?",
        (note_id,),
    ).fetchone()[0]
    file_count = conn.execute(
        "SELECT COUNT(*) FROM note_file WHERE note_id=?",
        (note_id,),
    ).fetchone()[0]
    # Basic note info
    note_row = conn.execute(
        "SELECT title, notebook FROM note WHERE id=?",
        (note_id,),
    ).fetchone()
    title = note_row[0] if note_row else None
    notebook = note_row[1] if note_row else None
    # Source mapping
    source_key_row = conn.execute(
        "SELECT source_key FROM note_source WHERE note_id=?",
        (note_id,),
    ).fetchone()
    source_key = source_key_row[0] if source_key_row else None
    # Overall text stats
    chars = len(raw_text)
    lines = raw_text.count("\n") + (1 if raw_text and not raw_text.endswith("\n") else 0)
    words = len([w for w in raw_text.split() if w])
    # Per-page summary
    pages: list[dict] = []
    cur = conn.execute(
        """
        SELECT tp.page_order, tp.id, tp.text, tp.json_path, tp.file_id, tp.page_date, tp.page_date_precision,
               f.path, f.original_filename, f.ocr_text_path, f.ocr_json_path, f.sha256
        FROM transcribed_page tp
        LEFT JOIN file f ON tp.file_id = f.id
        WHERE tp.note_id=?
        ORDER BY tp.page_order ASC, tp.id ASC
        """,
        (note_id,),
    )
    for (page_order, tpid, ptext, json_path, file_id, page_date, page_prec, fpath, orig_name, ocr_txt_path, ocr_json_path, sha256) in cur.fetchall():
        ptext = ptext or ""
        p_chars = len(ptext)
        p_lines = ptext.count("\n") + (1 if ptext and not ptext.endswith("\n") else 0)
        p_words = len([w for w in ptext.split() if w])
        pages.append(
            {
                "page_order": int(page_order) if page_order is not None else None,
                "transcribed_page_id": int(tpid),
                "file_id": int(file_id) if file_id is not None else None,
                "page_date": page_date,
                "page_date_precision": page_prec,
                "image_path": fpath,
                "original_filename": orig_name,
                "ocr_text_path": ocr_txt_path,
                "ocr_json_path": ocr_json_path or json_path,
                "sha256": sha256,
                "text_stats": {"chars": p_chars, "lines": p_lines, "words": p_words},
            }
        )

    # Note-level date
    nrow = conn.execute("SELECT date_created, date_created_precision FROM note WHERE id=?", (note_id,)).fetchone()
    note_date = nrow[0] if nrow else None
    note_date_precision = nrow[1] if nrow else None

    meta = {
        "source_key": source_key,
        "title": title,
        "notebook": notebook,
        "date_created": note_date,
        "date_created_precision": note_date_precision,
        "page_count": int(page_count),
        "file_count": int(file_count),
        "text_stats": {"chars": chars, "lines": lines, "words": words},
        "pages": pages,
        "assembled_at": datetime.now(timezone.utc).isoformat(),
        "assembled_by": "notesdb-assemble",
    }
    return json.dumps(meta, ensure_ascii=False)


def assemble(conn: sqlite3.Connection, note_id: int | None, only_missing: bool, overwrite: bool) -> tuple[int, int]:
    # If no transcribed_page table, nothing to assemble in the new schema
    if not _has_table(conn, "transcribed_page"):
        return 0, 0
    updated = 0
    skipped = 0
    for nid in iter_target_notes(conn, note_id, only_missing):
        # Prefer new content column; fallback to raw_text if present
        col = "content" if _has_column(conn, "note", "content") else "raw_text"
        row = conn.execute(f"SELECT {col} FROM note WHERE id=?", (nid,)).fetchone()
        current = row[0] if row else None
        if current and not overwrite and only_missing:
            skipped += 1
            continue
        raw = build_note_text(conn, nid)
        meta = build_metadata(conn, nid, raw)
        conn.execute(f"UPDATE note SET {col}=?, metadata_json=? WHERE id=?", (raw, meta, nid))
        updated += 1
    return updated, skipped


def main() -> int:
    ap = argparse.ArgumentParser(description="Assemble note.raw_text and metadata_json from transcribed pages")
    ap.add_argument("--db", default=os.environ.get("NOTES_DB", "/data/notesdb/notes.db"))
    ap.add_argument("--note-id", type=int)
    ap.add_argument("--only-missing", action="store_true", help="Only fill notes with empty raw_text")
    ap.add_argument("--overwrite", action="store_true", help="Overwrite existing raw_text")
    args = ap.parse_args()

    with closing(open_db(args.db)) as conn:
        with conn:
            # If schema is new (no transcribed_page or raw_text), no-op gracefully
            if not _has_table(conn, "transcribed_page") and _has_column(conn, "note", "content"):
                print("[notesdb-assemble] new schema detected (content, no transcribed_page); nothing to assemble.")
                return 0
            updated, skipped = assemble(conn, args.note_id, args.only_missing, args.overwrite)
    print(f"[notesdb-assemble] updated={updated} skipped={skipped}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
