#!/usr/bin/env python
"""
Scan /data/newdata for inputs and run the PDF → pages → blocks → images → markdown pipeline.

Modular steps (PDFs first):
- pdf-to-pages: per-page PNG + blocks metadata under /data/ocr/<sha>/
- move-images: move PNGs to /data/images with canonical names
- assemble-md: build a single Markdown file from blocks JSON
- move source PDF to /data/newdata/processed
"""
from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path
import hashlib
import shutil
import subprocess
import json
import os


IMAGE_EXTS = {".png", ".jpg", ".jpeg", ".tif", ".tiff", ".bmp", ".webp"}
PDF_EXTS = {".pdf"}
TEXT_EXTS = {".txt", ".md", ".rtf", ".docx", ".doc", ".odt", ".html", ".htm", ".tex", ".epub"}


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Ingest new data and route to OCR or text conversion")
    p.add_argument("--root", default=os.environ.get("NEWDATA_DIR", "/data/newdata"), help="Input root directory")
    p.add_argument("--images-dir", default=os.environ.get("IMAGES_DIR", "/data/images"))
    p.add_argument("--ocr-dir", default=os.environ.get("OCR_DIR", "/data/ocr"))
    p.add_argument("--notes-db", default=os.environ.get("NOTES_DB", "/data/notesdb/notes.db"))
    p.add_argument("--engine", default=os.environ.get("OCR_ENGINE", "tesseract"), help="OCR engine: tesseract|paddle")
    p.add_argument("--langs", default=os.environ.get("OCR_LANGS", "eng"), help="OCR language codes")
    env_move = os.environ.get("MOVE_PROCESSED", "1").lower() in ("1", "true", "yes", "on")
    p.add_argument("--move-processed", action="store_true", default=env_move, help="Move processed files to _processed (env MOVE_PROCESSED)")
    p.add_argument("--since", help="Only process files modified since this ISO timestamp or epoch seconds")
    p.add_argument("--max-workers", type=int, default=1)
    p.add_argument("--watch", action="store_true", help="Watch for new files (not implemented in scaffold)")
    p.add_argument("--dry-run", action="store_true")
    return p.parse_args()


def classify(path: Path) -> str:
    ext = path.suffix.lower()
    if ext in IMAGE_EXTS:
        return "image"
    if ext in PDF_EXTS:
        return "pdf"
    if ext in TEXT_EXTS:
        return "text"
    return "unknown"


def main() -> int:
    args = parse_args()
    root = Path(args.root)
    if not root.exists():
        print(f"[ingest] root not found: {root}", file=sys.stderr)
        return 1
    pdf_files = [p for p in root.rglob("*.pdf") if p.is_file()]
    image_files = [
        p for p in root.rglob("*")
        if p.is_file() and p.suffix.lower() in IMAGE_EXTS and "/processed/" not in str(p)
    ]
    text_files = [
        p for p in root.rglob("*")
        if p.is_file() and p.suffix.lower() in TEXT_EXTS and "/processed/" not in str(p)
    ]
    if not pdf_files and not image_files and not text_files:
        print("[ingest] No PDF, image, or text files to process.")
        return 0
    processed_dir = root / "processed"
    processed_dir.mkdir(parents=True, exist_ok=True)

    # 1) Handle PDFs → pages → images → OCR
    for pdf in sorted(pdf_files):
        # Compute sha for stable ocr dir and naming
        h = hashlib.sha256()
        with open(pdf, "rb") as f:
            for chunk in iter(lambda: f.read(1024 * 1024), b""):
                h.update(chunk)
        sha = h.hexdigest()
        ocr_root = Path(args.ocr_dir) / sha
        pages_dir = ocr_root / "pages"
        done_marker = ocr_root / "done.marker"

        if done_marker.exists():
            print(f"[ingest] Skip already processed {pdf} ({sha})")
            continue

        print(f"[ingest] Processing {pdf} → sha={sha}")
        # 1) pdf-to-pages (always render pages)
        cmd = [
            "pdf-to-pages",
            str(pdf),
            "--outdir",
            args.ocr_dir,
            "--subdir",
            sha,
            "--dpi",
            "300",
        ]
        if args.dry_run:
            cmd.append("--dry-run")
        subprocess.run(cmd, check=True)

        if args.dry_run:
            # Show planned OCR on pages
            subprocess.run(["ocr-image", str(pages_dir), "--dry-run"], check=False)
            continue

        if not args.dry_run:
            success = False
            # Always run OCR over rendered pages
            try:
                subprocess.run(["ocr-image", str(pages_dir)], check=True)
            except subprocess.CalledProcessError as e:
                print(f"[ingest] OCR failed for {pdf}: {e}")
                success = False
            else:
                # Consider success if any OCR JSON exists
                ocr_jsons = list(pages_dir.glob("*.ocr.json"))
                success = len(ocr_jsons) > 0

            if not success:
                print(f"[ingest] No text detected for {pdf}; leaving source in place.")
                continue

            # 2) move-images
            subprocess.run([
                "move-images",
                "--pages-dir",
                str(pages_dir),
                "--images-dir",
                args.images_dir,
                "--source",
                str(pdf),
            ], check=True)

            # 3) assemble-md
            subprocess.run([
                "assemble-md",
                "--ocr-root",
                str(ocr_root),
                "--images-dir",
                args.images_dir,
            ], check=True)

            # 3b) write OCR batch manifest for provenance
            try:
                subprocess.run([
                    "write-ocr-manifest",
                    "--ocr-root",
                    str(ocr_root),
                    "--engine",
                    args.engine,
                    "--images-dir",
                    args.images_dir,
                ], check=True)
            except subprocess.CalledProcessError as e:
                print(f"[ingest] write-ocr-manifest failed for {ocr_root}: {e}")

            # 4) write notes DB
            manifest = ocr_root / "moved_images.json"
            if manifest.exists():
                subprocess.run([
                    "notesdb-write",
                    "--db",
                    args.notes_db,
                    "--manifest",
                    str(manifest),
                    "--images-dir",
                    args.images_dir,
                ], check=True)
                # Assemble note text/metadata for any newly written notes
                subprocess.run([
                    "notesdb-assemble",
                    "--db",
                    args.notes_db,
                    "--only-missing",
                ], check=True)
                # Infer dates for new pages/notes
                subprocess.run([
                    "notesdb-dates",
                    "--db",
                    args.notes_db,
                    "--only-missing",
                ], check=True)
                # Link scripture passages
                subprocess.run([
                    "notesdb-passages",
                    "--notes-db",
                    args.notes_db,
                    "--std-db",
                    os.environ.get("STANDARD_WORKS_DB", "/data/scripdb/standardworks.db")
                ], check=True)

            # 5) mark done and move source
            done_marker.write_text("ok", encoding="utf-8")
            if args.move_processed:
                dest = processed_dir / pdf.name
                shutil.move(str(pdf), str(dest))
                print(f"[ingest] moved source -> {dest}")

    # 2) Handle standalone image files → move into images → OCR
    if image_files:
        print(f"[ingest] Found {len(image_files)} image(s) to move and OCR.")
    for img in sorted(image_files):
        # Derive destination name based on content sha
        h = hashlib.sha256(img.read_bytes()).hexdigest()
        dest = Path(args.images_dir) / f"scan-{h[:16]}{img.suffix.lower()}"
        if args.dry_run:
            print(f"[ingest] would move {img} -> {dest}")
            subprocess.run(["ocr-image", str(dest), "--dry-run"], check=False)
        else:
            Path(args.images_dir).mkdir(parents=True, exist_ok=True)
            shutil.move(str(img), str(dest))
            try:
                subprocess.run(["ocr-image", str(dest)], check=True)
            except subprocess.CalledProcessError as e:
                print(f"[ingest] OCR failed for {dest}: {e}")
            else:
                # Persist into notes DB as a single-page note
                try:
                    subprocess.run([
                        "notesdb-write",
                        "--db",
                        args.notes_db,
                        "--paths",
                        str(dest),
                        "--original-name",
                        img.name,
                    ], check=True)
                except subprocess.CalledProcessError as e:
                    print(f"[ingest] notesdb-write failed for {dest}: {e}")
                else:
                    subprocess.run([
                        "notesdb-assemble",
                        "--db",
                        args.notes_db,
                        "--only-missing",
                    ], check=True)
                    subprocess.run([
                        "notesdb-dates",
                        "--db",
                        args.notes_db,
                        "--only-missing",
                    ], check=True)
                    subprocess.run([
                        "notesdb-passages",
                        "--notes-db",
                        args.notes_db,
                        "--std-db",
                        os.environ.get("STANDARD_WORKS_DB", "/data/scripdb/standardworks.db")
                    ], check=True)

    # 3) Handle text files (md/html/txt/docx/rtf/odt/epub/tex)
    if text_files:
        print(f"[ingest] Found {len(text_files)} text file(s) to import.")
    for tfile in sorted(text_files):
        if args.dry_run:
            print(f"[ingest] would import text {tfile}")
            continue
        try:
            subprocess.run([
                "notesdb-import-text",
                "--db",
                args.notes_db,
                str(tfile),
            ], check=True)
        except subprocess.CalledProcessError as e:
            print(f"[ingest] notesdb-import-text failed for {tfile}: {e}")
            continue
        # Post-process: move processed text file
        if args.move_processed:
            destp = processed_dir / tfile.name
            destp.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(str(tfile), str(destp))

    print("[ingest] Done.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
