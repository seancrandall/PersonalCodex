#!/usr/bin/env python3
from __future__ import annotations

import argparse
import html
import io
import json
import os
import re
import sqlite3
import zipfile
from contextlib import closing
from pathlib import Path
from typing import Optional


TEXT_EXTS = {".txt", ".md", ".rtf", ".docx", ".odt", ".html", ".htm", ".tex", ".epub"}


def to_text(path: Path) -> str:
    ext = path.suffix.lower()
    if ext == ".txt":
        return path.read_text(encoding="utf-8", errors="ignore")
    if ext == ".md":
        # Minimal cleanup: strip code fences, headers; leave content otherwise
        s = path.read_text(encoding="utf-8", errors="ignore")
        s = re.sub(r"^```[\s\S]*?^```", "", s, flags=re.MULTILINE)
        s = re.sub(r"^#+\s*", "", s, flags=re.MULTILINE)
        return s
    if ext in {".html", ".htm"}:
        s = path.read_text(encoding="utf-8", errors="ignore")
        s = re.sub(r"<script[\s\S]*?</script>", " ", s, flags=re.IGNORECASE)
        s = re.sub(r"<style[\s\S]*?</style>", " ", s, flags=re.IGNORECASE)
        s = re.sub(r"<[^>]+>", " ", s)
        return html.unescape(re.sub(r"\s+", " ", s)).strip()
    if ext == ".docx":
        with zipfile.ZipFile(path) as z:
            try:
                xml = z.read("word/document.xml").decode("utf-8", errors="ignore")
            except KeyError:
                return ""
        xml = re.sub(r"<w:tab[^>]*/>", "\t", xml)
        xml = re.sub(r"</w:p>", "\n\n", xml)
        text = re.sub(r"<[^>]+>", " ", xml)
        return html.unescape(re.sub(r"\s+", " ", text)).strip()
    if ext == ".odt":
        with zipfile.ZipFile(path) as z:
            try:
                xml = z.read("content.xml").decode("utf-8", errors="ignore")
            except KeyError:
                return ""
        xml = re.sub(r"</text:p>", "\n\n", xml)
        text = re.sub(r"<[^>]+>", " ", xml)
        return html.unescape(re.sub(r"\s+", " ", text)).strip()
    if ext == ".epub":
        with zipfile.ZipFile(path) as z:
            text_parts = []
            for name in z.namelist():
                if name.lower().endswith(('.xhtml', '.html', '.htm')):
                    try:
                        s = z.read(name).decode('utf-8', errors='ignore')
                    except Exception:
                        continue
                    s = re.sub(r"<script[\s\S]*?</script>", " ", s, flags=re.IGNORECASE)
                    s = re.sub(r"<style[\s\S]*?</style>", " ", s, flags=re.IGNORECASE)
                    s = re.sub(r"<[^>]+>", " ", s)
                    text_parts.append(html.unescape(re.sub(r"\s+", " ", s)).strip())
        return "\n\n".join(tp for tp in text_parts if tp)
    if ext == ".rtf":
        s = path.read_text(encoding="utf-8", errors="ignore")
        s = re.sub(r"\\[a-zA-Z]+-?\d* ?", "", s)
        s = re.sub(r"{\\[^}]+}", " ", s)
        s = re.sub(r"[{}]", " ", s)
        return re.sub(r"\s+", " ", s).strip()
    if ext == ".tex":
        s = path.read_text(encoding="utf-8", errors="ignore")
        s = re.sub(r"\\begin\{.*?\}[\s\S]*?\\end\{.*?\}", " ", s)
        s = re.sub(r"\\[a-zA-Z]+\*?(\[[^\]]*\])?(\{[^}]*\})?", " ", s)
        s = re.sub(r"\$[^$]*\$", " ", s)
        return re.sub(r"\s+", " ", s).strip()
    # Fallback: treat as text
    return path.read_text(encoding="utf-8", errors="ignore")


def open_db(path: str) -> sqlite3.Connection:
    conn = sqlite3.connect(path)
    conn.execute("PRAGMA foreign_keys=ON")
    conn.execute("PRAGMA busy_timeout=5000")
    return conn


def ensure_note_for_text(conn: sqlite3.Connection, source_key: str, title: str) -> int:
    row = conn.execute("SELECT note_id FROM note_source WHERE source_key=?", (source_key,)).fetchone()
    if row:
        return int(row[0])
    cur = conn.execute("INSERT INTO note(content, title) VALUES (?, ?)", ("", title))
    nid = int(cur.lastrowid)
    conn.execute("INSERT INTO note_source(note_id, source_key) VALUES (?, ?)", (nid, source_key))
    return nid


# --- Minimal date parsing for header or filename ---
MONTHS = {
    "jan": 1, "january": 1,
    "feb": 2, "february": 2,
    "mar": 3, "march": 3,
    "apr": 4, "april": 4,
    "may": 5,
    "jun": 6, "june": 6,
    "jul": 7, "july": 7,
    "aug": 8, "august": 8,
    "sep": 9, "sept": 9, "september": 9,
    "oct": 10, "october": 10,
    "nov": 11, "november": 11,
    "dec": 12, "december": 12,
}
ISO_RE = re.compile(r"\b(19\d{2}|20\d{2})[-/\.](0?[1-9]|1[0-2])[-/\.](0?[1-9]|[12]\d|3[01])\b")
NUM_RE = re.compile(r"\b(0?[1-9]|1[0-2])[\-\./_](0?[1-9]|[12]\d|3[01])[\-\./_](\d{2,4}|'\d{2}|’\d{2})\b")
NAME1_RE = re.compile(r"\b(\w{3,9})\.?,?\s+([0-3]?\d)(?:st|nd|rd|th)?(?:,)?\s+(\d{2,4}|'\d{2}|’\d{2})\b", re.IGNORECASE)
NAME2_RE = re.compile(r"\b([0-3]?\d)(?:st|nd|rd|th)?\s+(\w{3,9})\.?,?\s+(\d{2,4}|'\d{2}|’\d{2})\b", re.IGNORECASE)
COMPACT_YMD_RE = re.compile(r"\b(19\d{2}|20\d{2})(0[1-9]|1[0-2])([012]\d|3[01])\b")
YM_ISO_RE = re.compile(r"\b(19\d{2}|20\d{2})[-/\.](0?[1-9]|1[0-2])\b")
MY_NAME_RE = re.compile(r"\b(\w{3,9})\.?,?\s+(\d{2,4}|'\d{2}|’\d{2})\b", re.IGNORECASE)
Y_ONLY_RE = re.compile(r"\b(19\d{2}|20\d{2})\b")


def _pad(n: int) -> str:
    return f"{n:02d}"


def _normalize_year(y: int) -> int:
    if y < 100:
        return 2000 + y if y <= 49 else 1900 + y
    return y


def _valid_date(y: int, m: int, d: int) -> bool:
    try:
        import datetime as _dt
        _dt.date(_normalize_year(y), m, d)
        return True
    except Exception:
        return False


def _parse_yy_fragment(val: str) -> int:
    val = val.strip().lstrip("'").lstrip("’")
    try:
        return int(val)
    except Exception:
        return 0


def parse_date_str(s: str):
    if not s:
        return None
    m = ISO_RE.search(s)
    if m:
        y, mo, da = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}", "day"
    m = NAME1_RE.search(s)
    if m:
        mon = MONTHS.get(m.group(1).lower().rstrip('.'))
        if mon:
            d = int(m.group(2))
            y = _parse_yy_fragment(m.group(3))
            if _valid_date(y, mon, d):
                return f"{_normalize_year(y)}-{_pad(mon)}-{_pad(d)}", "day"
    m = NAME2_RE.search(s)
    if m:
        d = int(m.group(1))
        mon = MONTHS.get(m.group(2).lower().rstrip('.'))
        y = _parse_yy_fragment(m.group(3))
        if mon and _valid_date(y, mon, d):
            return f"{_normalize_year(y)}-{_pad(mon)}-{_pad(d)}", "day"
    m = NUM_RE.search(s)
    if m:
        mo, da, yfrag = int(m.group(1)), int(m.group(2)), _parse_yy_fragment(m.group(3))
        y = yfrag
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}", "day"
    m = COMPACT_YMD_RE.search(s)
    if m:
        y, mo, da = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}", "day"
    m = YM_ISO_RE.search(s)
    if m:
        y, mo = int(m.group(1)), int(m.group(2))
        if 1 <= mo <= 12:
            return f"{_normalize_year(y)}-{_pad(mo)}-01", "month"
    m = MY_NAME_RE.search(s)
    if m:
        mon = MONTHS.get(m.group(1).lower().rstrip('.'))
        y = _parse_yy_fragment(m.group(2))
        if mon and y:
            return f"{_normalize_year(y)}-{_pad(mon)}-01", "month"
    m = Y_ONLY_RE.search(s)
    if m:
        y = int(m.group(1))
        return f"{_normalize_year(y)}-01-01", "year"
    return None


def set_note_date_from_text_or_name(conn: sqlite3.Connection, nid: int, text: str, filename: str) -> None:
    head = (text or "")[:300]
    dprec = parse_date_str(head) or parse_date_str(filename)
    if dprec:
        d, prec = dprec
        conn.execute("UPDATE note SET date_created=?, date_created_precision=? WHERE id=?", (d, prec, nid))


def main() -> int:
    ap = argparse.ArgumentParser(description="Import text files into notes.db (one note per file)")
    ap.add_argument("--db", default=os.environ.get("NOTES_DB", "/data/notesdb/notes.db"))
    ap.add_argument("paths", nargs="+", help="Text files to import")
    args = ap.parse_args()

    with closing(open_db(args.db)) as conn:
        with conn:
            for p in args.paths:
                path = Path(p)
                if path.suffix.lower() not in TEXT_EXTS:
                    print(f"[notesdb-import-text] skip (not text): {path}")
                    continue
                try:
                    text = to_text(path)
                except Exception as e:
                    print(f"[notesdb-import-text] failed to parse {path}: {e}")
                    continue
                title = path.stem
                # Source key from relative path under newdata if possible
                try:
                    rel = str(path.relative_to(Path('volumes/newdata')))
                except Exception:
                    rel = str(path)
                source_key = f"text:{rel}"
                nid = ensure_note_for_text(conn, source_key, title)
                # Write content and infer date
                conn.execute("UPDATE note SET content=? WHERE id=?", (text, nid))
                set_note_date_from_text_or_name(conn, nid, text, path.name)
                print(f"[notesdb-import-text] imported {path} -> note {nid}")
        # Post-processing: scripture passages
        for p in args.paths:
            path = Path(p)
            try:
                rel = str(path.relative_to(Path('volumes/newdata')))
            except Exception:
                rel = str(path)
            source_key = f"text:{rel}"
            row = conn.execute("SELECT note_id FROM note_source WHERE source_key=?", (source_key,)).fetchone()
            if not row:
                continue
            nid = int(row[0])
            # Link passages
            std_db = os.environ.get("STANDARD_WORKS_DB", "/data/scripdb/standardworks.db")
            alias = os.environ.get("BOOK_ALIASES", "/data/scripdb/book_aliases.json")
            os.system(f"volumes/bin/notesdb-passages --notes-db {args.db} --std-db {std_db} --aliases {alias} --note-id {nid} >/dev/null 2>&1 || true")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
