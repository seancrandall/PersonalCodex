#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
import sqlite3
from contextlib import closing
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple


MONTHS = {
    "jan": 1, "january": 1,
    "feb": 2, "february": 2,
    "mar": 3, "march": 3,
    "apr": 4, "april": 4,
    "may": 5,
    "jun": 6, "june": 6,
    "jul": 7, "july": 7,
    "aug": 8, "august": 8,
    "sep": 9, "sept": 9, "september": 9,
    "oct": 10, "october": 10,
    "nov": 11, "november": 11,
    "dec": 12, "december": 12,
}


ISO_RE = re.compile(r"\b(19\d{2}|20\d{2})-(0?[1-9]|1[0-2])-(0?[1-9]|[12]\d|3[01])\b")
NUM_RE = re.compile(r"\b(0?[1-9]|1[0-2])[/-](0?[1-9]|[12]\d|3[01])[/-](\d{2,4})\b")
NAME1_RE = re.compile(
    r"\b(\w{3,9})\.?,?\s+([0-3]?\d)(?:st|nd|rd|th)?(?:,)?\s+(\d{2,4})\b",
    re.IGNORECASE,
)
NAME2_RE = re.compile(
    r"\b([0-3]?\d)(?:st|nd|rd|th)?\s+(\w{3,9})\.?,?\s+(\d{2,4})\b",
    re.IGNORECASE,
)
COMPACT_YMD_RE = re.compile(r"\b(19\d{2}|20\d{2})(0[1-9]|1[0-2])([012]\d|3[01])\b")


def _pad(n: int) -> str:
    return f"{n:02d}"


def _normalize_year(y: int) -> int:
    if y < 100:
        return 2000 + y if y <= 49 else 1900 + y
    return y


def _valid_date(y: int, m: int, d: int) -> bool:
    try:
        datetime(_normalize_year(y), m, d)
        return True
    except ValueError:
        return False


def parse_date_str(s: str) -> Optional[str]:
    if not s:
        return None
    # ISO 8601
    m = ISO_RE.search(s)
    if m:
        y, mo, da = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}"
    # Month name first
    m = NAME1_RE.search(s)
    if m:
        mon = MONTHS.get(m.group(1).lower().rstrip('.'), None)
        if mon:
            d = int(m.group(2))
            y = int(m.group(3))
            if _valid_date(y, mon, d):
                return f"{_normalize_year(y)}-{_pad(mon)}-{_pad(d)}"
    # Day first then month name
    m = NAME2_RE.search(s)
    if m:
        d = int(m.group(1))
        mon = MONTHS.get(m.group(2).lower().rstrip('.'), None)
        y = int(m.group(3))
        if mon and _valid_date(y, mon, d):
            return f"{_normalize_year(y)}-{_pad(mon)}-{_pad(d)}"
    # Numeric US
    m = NUM_RE.search(s)
    if m:
        mo, da, y = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}"
    # Compact YYYYMMDD
    m = COMPACT_YMD_RE.search(s)
    if m:
        y, mo, da = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}"
    return None


def find_date_in_text(text: str, head_chars: int = 300) -> Optional[str]:
    if not text:
        return None
    head = text[:head_chars]
    return parse_date_str(head)


def find_date_for_page(conn: sqlite3.Connection, note_id: int, page_order: int, file_orig_name: Optional[str], lookback: int) -> Tuple[Optional[str], str]:
    # 1) Own text
    row = conn.execute(
        "SELECT text FROM transcribed_page WHERE note_id=? AND page_order=?",
        (note_id, page_order),
    ).fetchone()
    if row:
        d = find_date_in_text(row[0] or "")
        if d:
            return d, "text"
    # 2) Previous pages up to lookback
    for delta in range(1, lookback + 1):
        prev = page_order - delta
        if prev < 1:
            break
        prow = conn.execute(
            "SELECT text FROM transcribed_page WHERE note_id=? AND page_order=?",
            (note_id, prev),
        ).fetchone()
        if prow:
            d = find_date_in_text(prow[0] or "")
            if d:
                return d, "previous"
    # 3) Original filename
    if file_orig_name:
        d = parse_date_str(file_orig_name)
        if d:
            return d, "filename"
    return None, ""


def process_note(conn: sqlite3.Connection, note_id: int, only_missing: bool, lookback: int) -> Tuple[int, int]:
    updated_pages = 0
    rows = conn.execute(
        """
        SELECT tp.page_order, tp.page_date, f.original_filename
        FROM transcribed_page tp
        LEFT JOIN file f ON tp.file_id = f.id
        WHERE tp.note_id=?
        ORDER BY tp.page_order ASC
        """,
        (note_id,),
    ).fetchall()
    note_dates = []
    for (page_order, page_date, orig_name) in rows:
        if page_date and only_missing:
            if page_date:
                note_dates.append(page_date)
            continue
        d, source = find_date_for_page(conn, note_id, int(page_order), orig_name, lookback)
        if d and d != page_date:
            conn.execute(
                "UPDATE transcribed_page SET page_date=? WHERE note_id=? AND page_order=?",
                (d, note_id, page_order),
            )
            updated_pages += 1
            note_dates.append(d)
        elif page_date:
            note_dates.append(page_date)
    # Set note.date_created as the earliest page_date in the note
    note_date = None
    for d in sorted({nd for nd in note_dates if nd}):
        note_date = d
        break
    if note_date:
        conn.execute("UPDATE note SET date_created=? WHERE id=?", (note_date, note_id))
    return updated_pages, 1 if note_date else 0


def iter_note_ids(conn: sqlite3.Connection, note_id: Optional[int]):
    if note_id:
        yield note_id
        return
    for (nid,) in conn.execute("SELECT id FROM note ORDER BY id"):
        yield int(nid)


def main() -> int:
    ap = argparse.ArgumentParser(description="Infer and update dates for pages and notes")
    ap.add_argument("--db", default="/data/notesdb/notes.db")
    ap.add_argument("--note-id", type=int)
    ap.add_argument("--only-missing", action="store_true")
    ap.add_argument("--lookback", type=int, default=5)
    args = ap.parse_args()

    with closing(sqlite3.connect(args.db)) as conn:
        conn.execute("PRAGMA foreign_keys=ON")
        total_pages = 0
        notes_with_date = 0
        with conn:
            for nid in iter_note_ids(conn, args.note_id):
                up_pages, note_has_date = process_note(conn, nid, args.only_missing, args.lookback)
                total_pages += up_pages
                notes_with_date += note_has_date
    print(f"[notesdb-dates] page_updates={total_pages} notes_with_date={notes_with_date}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

