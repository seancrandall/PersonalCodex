#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
import sqlite3
from contextlib import closing
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple


MONTHS = {
    "jan": 1, "january": 1,
    "feb": 2, "february": 2,
    "mar": 3, "march": 3,
    "apr": 4, "april": 4,
    "may": 5,
    "jun": 6, "june": 6,
    "jul": 7, "july": 7,
    "aug": 8, "august": 8,
    "sep": 9, "sept": 9, "september": 9,
    "oct": 10, "october": 10,
    "nov": 11, "november": 11,
    "dec": 12, "december": 12,
}


ISO_RE = re.compile(r"\b(19\d{2}|20\d{2})[-/\.](0?[1-9]|1[0-2])[-/\.](0?[1-9]|[12]\d|3[01])\b")
NUM_RE = re.compile(r"\b(0?[1-9]|1[0-2])[\-\./_](0?[1-9]|[12]\d|3[01])[\-\./_](\d{2,4}|'\d{2}|’\d{2})\b")
NAME1_RE = re.compile(
    r"\b(\w{3,9})\.?,?\s+([0-3]?\d)(?:st|nd|rd|th)?(?:,)?\s+(\d{2,4}|'\d{2}|’\d{2})\b",
    re.IGNORECASE,
)
NAME2_RE = re.compile(
    r"\b([0-3]?\d)(?:st|nd|rd|th)?\s+(\w{3,9})\.?,?\s+(\d{2,4}|'\d{2}|’\d{2})\b",
    re.IGNORECASE,
)
COMPACT_YMD_RE = re.compile(r"\b(19\d{2}|20\d{2})(0[1-9]|1[0-2])([012]\d|3[01])\b")
YM_ISO_RE = re.compile(r"\b(19\d{2}|20\d{2})[-/\.](0?[1-9]|1[0-2])\b")
MY_NAME_RE = re.compile(r"\b(\w{3,9})\.?,?\s+(\d{2,4}|'\d{2}|’\d{2})\b", re.IGNORECASE)
Y_ONLY_RE = re.compile(r"\b(19\d{2}|20\d{2})\b")


def _pad(n: int) -> str:
    return f"{n:02d}"


def _normalize_year(y: int) -> int:
    if y < 100:
        return 2000 + y if y <= 49 else 1900 + y
    return y


def _valid_date(y: int, m: int, d: int) -> bool:
    try:
        datetime(_normalize_year(y), m, d)
        return True
    except ValueError:
        return False


def _parse_yy_fragment(val: str) -> int:
    val = val.strip().lstrip("'").lstrip("’")
    try:
        return int(val)
    except Exception:
        return 0


def parse_date_str(s: str) -> Optional[tuple[str, str]]:
    if not s:
        return None
    # ISO 8601
    m = ISO_RE.search(s)
    if m:
        y, mo, da = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}", "day"
    # Month name first
    m = NAME1_RE.search(s)
    if m:
        mon = MONTHS.get(m.group(1).lower().rstrip('.'), None)
        if mon:
            d = int(m.group(2))
            y = _parse_yy_fragment(m.group(3))
            if _valid_date(y, mon, d):
                return f"{_normalize_year(y)}-{_pad(mon)}-{_pad(d)}", "day"
    # Day first then month name
    m = NAME2_RE.search(s)
    if m:
        d = int(m.group(1))
        mon = MONTHS.get(m.group(2).lower().rstrip('.'), None)
        y = _parse_yy_fragment(m.group(3))
        if mon and _valid_date(y, mon, d):
            return f"{_normalize_year(y)}-{_pad(mon)}-{_pad(d)}", "day"
    # Numeric US
    m = NUM_RE.search(s)
    if m:
        mo, da, yfrag = int(m.group(1)), int(m.group(2)), _parse_yy_fragment(m.group(3))
        y = yfrag
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}", "day"
    # Compact YYYYMMDD
    m = COMPACT_YMD_RE.search(s)
    if m:
        y, mo, da = int(m.group(1)), int(m.group(2)), int(m.group(3))
        if _valid_date(y, mo, da):
            return f"{_normalize_year(y)}-{_pad(mo)}-{_pad(da)}", "day"
    # Year-month without day
    m = YM_ISO_RE.search(s)
    if m:
        y, mo = int(m.group(1)), int(m.group(2))
        if 1 <= mo <= 12:
            return f"{_normalize_year(y)}-{_pad(mo)}-01", "month"
    # Month name + year
    m = MY_NAME_RE.search(s)
    if m:
        mon = MONTHS.get(m.group(1).lower().rstrip('.'), None)
        y = _parse_yy_fragment(m.group(2))
        if mon and y:
            return f"{_normalize_year(y)}-{_pad(mon)}-01", "month"
    # Year only
    m = Y_ONLY_RE.search(s)
    if m:
        y = int(m.group(1))
        return f"{_normalize_year(y)}-01-01", "year"
    return None


def find_date_in_text(text: str, head_chars: int = 600, head_lines: int = 5) -> Optional[tuple[str, str]]:
    if not text:
        return None
    # Try first N non-empty lines
    lines = [ln.strip() for ln in text.splitlines() if ln.strip()][: head_lines]
    for ln in lines:
        parsed = parse_date_str(ln)
        if parsed:
            return parsed
    # Fallback to first chunk of text
    head = text[:head_chars]
    return parse_date_str(head)


def find_date_for_page(conn: sqlite3.Connection, note_id: int, page_order: int, file_orig_name: Optional[str], lookback: int) -> Tuple[Optional[str], str, Optional[str]]:
    # 1) Own text
    row = conn.execute(
        "SELECT text FROM transcribed_page WHERE note_id=? AND page_order=?",
        (note_id, page_order),
    ).fetchone()
    if row:
        res = find_date_in_text(row[0] or "")
        if res:
            d, prec = res
            return d, "text", prec
    # 2) Previous pages up to lookback
    for delta in range(1, lookback + 1):
        prev = page_order - delta
        if prev < 1:
            break
        prow = conn.execute(
            "SELECT text FROM transcribed_page WHERE note_id=? AND page_order=?",
            (note_id, prev),
        ).fetchone()
        if prow:
            res = find_date_in_text(prow[0] or "")
            if res:
                d, prec = res
                return d, "previous", prec
    # 3) Original filename
    if file_orig_name:
        res = parse_date_str(file_orig_name)
        if res:
            d, prec = res
            return d, "filename", prec
    return None, "", None


def process_note(conn: sqlite3.Connection, note_id: int, only_missing: bool, lookback: int) -> Tuple[int, int]:
    updated_pages = 0
    rows = conn.execute(
        """
        SELECT tp.page_order, tp.page_date, f.original_filename
        FROM transcribed_page tp
        LEFT JOIN file f ON tp.file_id = f.id
        WHERE tp.note_id=?
        ORDER BY tp.page_order ASC
        """,
        (note_id,),
    ).fetchall()
    note_dates = []
    for (page_order, page_date, orig_name) in rows:
        if page_date and only_missing:
            if page_date:
                note_dates.append(page_date)
            continue
        d, source, prec = find_date_for_page(conn, note_id, int(page_order), orig_name, lookback)
        if d and d != page_date:
            conn.execute(
                "UPDATE transcribed_page SET page_date=?, page_date_precision=? WHERE note_id=? AND page_order=?",
                (d, prec, note_id, page_order),
            )
            updated_pages += 1
            note_dates.append(d)
        elif page_date:
            note_dates.append(page_date)
    # Set note.date_created as the earliest page_date in the note
    note_date = None
    for d in sorted({nd for nd in note_dates if nd}):
        note_date = d
        break
    if note_date:
        # Determine precision of the chosen earliest date (first matching page)
        nprec_row = conn.execute(
            "SELECT page_date_precision FROM transcribed_page WHERE note_id=? AND page_date=? LIMIT 1",
            (note_id, note_date),
        ).fetchone()
        note_prec = nprec_row[0] if nprec_row else None
        conn.execute("UPDATE note SET date_created=?, date_created_precision=? WHERE id=?", (note_date, note_prec, note_id))
    return updated_pages, 1 if note_date else 0


def iter_note_ids(conn: sqlite3.Connection, note_id: Optional[int]):
    if note_id:
        yield note_id
        return
    for (nid,) in conn.execute("SELECT id FROM note ORDER BY id"):
        yield int(nid)


def main() -> int:
    ap = argparse.ArgumentParser(description="Infer and update dates for notes (new schema)")
    ap.add_argument("--db", default="/data/notesdb/notes.db")
    ap.add_argument("--note-id", type=int)
    ap.add_argument("--only-missing", action="store_true")
    ap.add_argument("--overwrite", action="store_true")
    ap.add_argument("--lookback", type=int, default=5)
    args = ap.parse_args()

    def _has_column(conn: sqlite3.Connection, table: str, column: str) -> bool:
        try:
            cols = [r[1] for r in conn.execute(f"PRAGMA table_info({table})").fetchall()]
            return column in cols
        except Exception:
            return False

    with closing(sqlite3.connect(args.db)) as conn:
        conn.execute("PRAGMA foreign_keys=ON")
        updated = 0
        with conn:
            for nid in iter_note_ids(conn, args.note_id):
                # Get existing date
                row = conn.execute("SELECT date_created FROM note WHERE id=?", (nid,)).fetchone()
                if not row:
                    continue
                if row[0] and args.only_missing and not args.overwrite:
                    continue
                # Read content
                col = "content" if _has_column(conn, "note", "content") else ("raw_text" if _has_column(conn, "note", "raw_text") else None)
                text = ""
                if col:
                    crow = conn.execute(f"SELECT {col} FROM note WHERE id=?", (nid,)).fetchone()
                    text = (crow[0] or "") if crow else ""
                # Lookback via prev_note_id chain
                prev_ids = []
                pid = conn.execute("SELECT prev_note_id FROM note WHERE id=?", (nid,)).fetchone()
                pid = pid[0] if pid else None
                hops = 0
                while pid and hops < args.lookback:
                    prev_ids.append(int(pid))
                    pid = conn.execute("SELECT prev_note_id FROM note WHERE id=?", (pid,)).fetchone()
                    pid = pid[0] if pid else None
                    hops += 1
                # Fallback inputfile name
                fname = None
                irow = conn.execute(
                    "SELECT ifl.original_filename FROM note_inputfile ni JOIN inputfile ifl ON ifl.id=ni.inputfile_id WHERE ni.note_id=? LIMIT 1",
                    (nid,),
                ).fetchone()
                if irow:
                    fname = irow[0]
                # Choose date per policy: head → prev chain → filename
                head = (text or "")[:300]
                dprec = find_date_in_text(head, head_chars=300)
                if not dprec:
                    for pid in prev_ids:
                        prow = conn.execute("SELECT date_created, date_created_precision FROM note WHERE id=?", (pid,)).fetchone()
                        if prow and prow[0]:
                            dprec = (prow[0], prow[1] or "day")
                            break
                if not dprec and fname:
                    dprec = parse_date_str(fname)
                if dprec:
                    d, prec = dprec
                    conn.execute("UPDATE note SET date_created=?, date_created_precision=? WHERE id=?", (d, prec, nid))
                    updated += 1
        print(f"[notesdb-dates] notes_updated={updated}")
        return 0


if __name__ == "__main__":
    raise SystemExit(main())
